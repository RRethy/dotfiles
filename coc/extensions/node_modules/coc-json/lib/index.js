"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const catalog_json_1 = tslib_1.__importDefault(require("./catalog.json"));
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const find_up_1 = tslib_1.__importDefault(require("find-up"));
const hash_1 = require("./utils/hash");
const coc_nvim_1 = require("coc.nvim");
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { subscriptions } = context;
        const config = coc_nvim_1.workspace.getConfiguration().get('json', {});
        if (!config.enable)
            return;
        const file = context.asAbsolutePath('lib/server/jsonServerMain.js');
        const selector = ['json', 'jsonc'];
        let schemaContent = yield readFile(path_1.default.join(coc_nvim_1.workspace.pluginRoot, 'data/schema.json'), 'utf8');
        let settingsSchema = JSON.parse(schemaContent);
        let serverOptions = {
            module: file,
            args: ['--node-ipc'],
            transport: coc_nvim_1.TransportKind.ipc,
            options: {
                cwd: coc_nvim_1.workspace.root,
                execArgv: config.execArgv
            }
        };
        let clientOptions = {
            documentSelector: selector,
            synchronize: {
                configurationSection: ['json', 'http'],
                fileEvents: coc_nvim_1.workspace.createFileSystemWatcher('**/*.json')
            },
            outputChannelName: 'json',
            middleware: {
                workspace: {
                    didChangeConfiguration: () => client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: getSettings() })
                },
                // fix completeItem
                provideCompletionItem: (document, position, context, token, next) => {
                    return Promise.resolve(next(document, position, context, token)).then((res) => {
                        let doc = coc_nvim_1.workspace.getDocument(document.uri);
                        if (!doc)
                            return [];
                        let items = res.hasOwnProperty('isIncomplete') ? res.items : res;
                        let line = doc.getline(position.line);
                        for (let item of items) {
                            let { textEdit, insertText, label, filterText } = item; // tslint:disable-line
                            item.insertText = null; // tslint:disable-line
                            if (textEdit && textEdit.newText) {
                                let newText = insertText || textEdit.newText;
                                textEdit.newText = newText;
                                let { start, end } = textEdit.range;
                                if (line[start.character] && line[end.character - 1] && /^".*"$/.test(label)) {
                                    item.label = item.label.slice(1, -1);
                                }
                            }
                            if (filterText && /^".*"$/.test(filterText)) {
                                item.filterText = filterText.slice(1, -1);
                            }
                        }
                        let result = {
                            isIncomplete: false,
                            items
                        };
                        if (items.length && items.every(o => o.kind == vscode_languageserver_protocol_1.CompletionItemKind.Property)) {
                            result.startcol = doc.fixStartcol(position, ['.']);
                        }
                        return result;
                    });
                }
            }
        };
        let client = new coc_nvim_1.LanguageClient('json', 'Json language server', serverOptions, clientOptions);
        subscriptions.push(coc_nvim_1.services.registLanguageClient(client));
        client.onReady().then(() => {
            for (let doc of coc_nvim_1.workspace.documents) {
                onDocumentCreate(doc.textDocument);
            }
            let associations = {};
            for (let item of catalog_json_1.default.schemas) {
                let { fileMatch, url } = item;
                if (Array.isArray(fileMatch)) {
                    for (let key of fileMatch) {
                        associations[key] = [url];
                    }
                }
                else if (typeof fileMatch === 'string') {
                    associations[fileMatch] = [url];
                }
            }
            associations['coc-settings.json'] = ['vscode://settings'];
            associations['app.json'] = [vscode_uri_1.default.file(context.asAbsolutePath('data/app.json')).toString()];
            client.sendNotification('json/schemaAssociations', associations);
            client.onRequest('vscode/content', (uri) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (uri == 'vscode://settings') {
                    let schema = Object.assign({}, settingsSchema);
                    schema.properties = schema.properties || {};
                    coc_nvim_1.extensions.all.forEach(extension => {
                        let { packageJSON } = extension;
                        let { contributes } = packageJSON;
                        if (!contributes)
                            return;
                        let { configuration } = contributes;
                        if (configuration) {
                            let { properties } = configuration;
                            if (properties) {
                                let props = schema.properties;
                                for (let key of Object.keys(properties)) {
                                    props[key] = properties[key];
                                }
                            }
                        }
                    });
                    return JSON.stringify(schema);
                }
                coc_nvim_1.workspace.showMessage(`Unsupported json uri ${uri}`, 'error');
                return '';
            }));
        }, _e => {
            // noop
        });
        const projectFile = yield find_up_1.default('project.config.json', { cwd: coc_nvim_1.workspace.root });
        const miniProgrameRoot = projectFile ? path_1.default.dirname(projectFile) : null;
        function onDocumentCreate(document) {
            if (!coc_nvim_1.workspace.match(selector, document))
                return;
            if (client.serviceState !== coc_nvim_1.ServiceStat.Running)
                return;
            let file = vscode_uri_1.default.parse(document.uri).fsPath;
            let associations = {};
            let content = document.getText();
            if (content.indexOf('"$schema"') !== -1)
                return;
            if (miniProgrameRoot) {
                if (path_1.default.dirname(file) == miniProgrameRoot) {
                    return;
                }
                let arr = ['page', 'component'].map(str => {
                    return vscode_uri_1.default.file(context.asAbsolutePath(`data/${str}.json`)).toString();
                });
                associations[file] = arr;
            }
            if (Object.keys(associations).length > 0) {
                client.sendNotification('json/schemaAssociations', associations);
            }
        }
        coc_nvim_1.workspace.onDidOpenTextDocument(onDocumentCreate, null, subscriptions);
    });
}
exports.activate = activate;
function getSettings() {
    let httpSettings = coc_nvim_1.workspace.getConfiguration('http');
    let schemas = [];
    coc_nvim_1.extensions.all.forEach(extension => {
        let { packageJSON } = extension;
        let { contributes } = packageJSON;
        if (!contributes)
            return;
        let { jsonValidation } = contributes;
        if (jsonValidation && jsonValidation.length) {
            schemas.push(...jsonValidation);
        }
    });
    let settings = {
        http: {
            proxy: httpSettings.get('proxy'),
            proxyStrictSSL: httpSettings.get('proxyStrictSSL')
        },
        json: {
            format: coc_nvim_1.workspace.getConfiguration('json').get('format'),
            schemas
        }
    };
    let schemaSettingsById = Object.create(null);
    let collectSchemaSettings = (schemaSettings, rootPath, fileMatchPrefix) => {
        for (let setting of schemaSettings) {
            let url = getSchemaId(setting, rootPath);
            if (!url) {
                continue;
            }
            let schemaSetting = schemaSettingsById[url];
            if (!schemaSetting) {
                schemaSetting = schemaSettingsById[url] = { url, fileMatch: [] };
                settings.json.schemas.push(schemaSetting);
            }
            let fileMatches = setting.fileMatch;
            let resultingFileMatches = schemaSetting.fileMatch;
            if (Array.isArray(fileMatches)) {
                if (fileMatchPrefix) {
                    for (let fileMatch of fileMatches) {
                        if (fileMatch[0] === '/') {
                            resultingFileMatches.push(fileMatchPrefix + fileMatch);
                            resultingFileMatches.push(fileMatchPrefix + '/*' + fileMatch);
                        }
                        else {
                            resultingFileMatches.push(fileMatchPrefix + '/' + fileMatch);
                            resultingFileMatches.push(fileMatchPrefix + '/*/' + fileMatch);
                        }
                    }
                }
                else {
                    resultingFileMatches.push(...fileMatches);
                }
            }
            if (setting.schema) {
                schemaSetting.schema = setting.schema;
            }
        }
    };
    // merge global and folder settings. Qualify all file matches with the folder path.
    let globalSettings = coc_nvim_1.workspace.getConfiguration('json', null).get('schemas');
    if (Array.isArray(globalSettings)) {
        collectSchemaSettings(globalSettings, coc_nvim_1.workspace.root);
    }
    return settings;
}
function getSchemaId(schema, rootPath) {
    let url = schema.url;
    if (!url) {
        if (schema.schema) {
            url = schema.schema.id || `vscode://schemas/custom/${encodeURIComponent(hash_1.hash(schema.schema).toString(16))}`;
        }
    }
    else if (rootPath && (url[0] === '.' || url[0] === '/')) {
        url = vscode_uri_1.default.file(path_1.default.normalize(path_1.default.join(rootPath, url))).toString();
    }
    return url;
}
function readFile(fullpath, encoding) {
    return new Promise((resolve, reject) => {
        fs_1.default.readFile(fullpath, encoding, (err, content) => {
            if (err)
                reject(err);
            resolve(content);
        });
    });
}
//# sourceMappingURL=index.js.map