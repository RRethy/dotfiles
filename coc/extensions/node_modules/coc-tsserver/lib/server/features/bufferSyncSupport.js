"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const api_1 = tslib_1.__importDefault(require("../utils/api"));
const async_1 = require("../utils/async");
const languageModeIds = tslib_1.__importStar(require("../utils/languageModeIds"));
function mode2ScriptKind(mode) {
    switch (mode) {
        case languageModeIds.typescript:
            return 'TS';
        case languageModeIds.typescripttsx:
            return 'TSX';
        case languageModeIds.typescriptjsx:
            return 'TSX';
        case languageModeIds.typescriptreact:
            return 'TSX';
        case languageModeIds.javascript:
            return 'JS';
        case languageModeIds.javascriptreact:
            return 'JSX';
    }
    return undefined;
}
class BufferSyncSupport {
    constructor(client, modeIds, validate) {
        this.uris = new Set();
        this.disposables = [];
        this.pendingDiagnostics = new Map();
        this.client = client;
        this.modeIds = new Set(modeIds);
        this._validate = validate || false;
        this.diagnosticDelayer = new async_1.Delayer(300);
    }
    listen() {
        coc_nvim_1.workspace.onDidOpenTextDocument(this.onDidOpenTextDocument, this, this.disposables);
        coc_nvim_1.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, this.disposables);
        coc_nvim_1.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, this.disposables);
        coc_nvim_1.workspace.textDocuments.forEach(this.onDidOpenTextDocument, this);
    }
    reInitialize() {
        coc_nvim_1.workspace.textDocuments.forEach(this.onDidOpenTextDocument, this);
    }
    set validate(value) {
        this._validate = value;
    }
    dispose() {
        this.pendingDiagnostics.clear();
        coc_nvim_1.disposeAll(this.disposables);
    }
    onDidOpenTextDocument(document) {
        if (!this.modeIds.has(document.languageId))
            return;
        let { uri } = document;
        let filepath = this.client.toPath(uri);
        this.uris.add(uri);
        const args = {
            file: filepath,
            fileContent: document.getText()
        };
        if (this.client.apiVersion.gte(api_1.default.v203)) {
            const scriptKind = mode2ScriptKind(document.languageId);
            if (scriptKind) {
                args.scriptKindName = scriptKind;
            }
        }
        if (this.client.apiVersion.gte(api_1.default.v230)) {
            args.projectRootPath = this.client.getWorkspaceRootForResource(document.uri);
        }
        this.client.execute('open', args, false); // tslint:disable-line
        this.requestDiagnostic(uri);
    }
    onDidCloseTextDocument(document) {
        let { uri } = document;
        if (!this.uris.has(uri))
            return;
        let filepath = this.client.toPath(uri);
        const args = {
            file: filepath
        };
        this.client.execute('close', args, false); // tslint:disable-line
    }
    onDidChangeTextDocument(e) {
        let { textDocument, contentChanges } = e;
        let { uri } = textDocument;
        if (!this.uris.has(uri))
            return;
        let filepath = this.client.toPath(uri);
        for (const { range, text } of contentChanges) {
            const args = {
                file: filepath,
                line: range ? range.start.line + 1 : 1,
                offset: range ? range.start.character + 1 : 1,
                endLine: range ? range.end.line + 1 : Math.pow(2, 24),
                endOffset: range ? range.end.character + 1 : 1,
                insertString: text
            };
            this.client.execute('change', args, false); // tslint:disable-line
        }
        this.requestDiagnostic(uri);
    }
    requestAllDiagnostics() {
        if (!this._validate) {
            return;
        }
        for (const uri of this.uris) {
            this.pendingDiagnostics.set(uri, Date.now());
        }
        this.diagnosticDelayer.trigger(() => {
            this.sendPendingDiagnostics();
        }, 200);
    }
    requestDiagnostic(uri) {
        if (!this._validate) {
            return;
        }
        let document = coc_nvim_1.workspace.getDocument(uri);
        if (!document)
            return;
        this.pendingDiagnostics.set(uri, Date.now());
        let delay = 300;
        const lineCount = document.lineCount;
        delay = Math.min(Math.max(Math.ceil(lineCount / 20), 300), 800);
        this.diagnosticDelayer.trigger(() => {
            this.sendPendingDiagnostics();
        }, delay); // tslint:disable-line
    }
    hasPendingDiagnostics(uri) {
        return this.pendingDiagnostics.has(uri);
    }
    sendPendingDiagnostics() {
        if (!this._validate) {
            return;
        }
        const files = Array.from(this.pendingDiagnostics.entries())
            .sort((a, b) => a[1] - b[1])
            .map(entry => this.client.toPath(entry[0]));
        // Add all open TS buffers to the geterr request. They might be visible
        for (const uri of this.uris) {
            if (!this.pendingDiagnostics.get(uri)) {
                let file = this.client.toPath(uri);
                files.push(file);
            }
        }
        if (files.length) {
            const args = {
                delay: 0,
                files
            };
            this.client.execute('geterr', args, false); // tslint:disable-line
        }
        this.pendingDiagnostics.clear();
    }
}
exports.default = BufferSyncSupport;
//# sourceMappingURL=bufferSyncSupport.js.map