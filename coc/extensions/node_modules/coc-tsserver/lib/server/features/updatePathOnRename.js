"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
}
class UpdateImportsOnFileRenameHandler {
    constructor(client, fileConfigurationManager, languageId) {
        this.client = client;
        this.fileConfigurationManager = fileConfigurationManager;
        this.disposables = [];
        let glob = languageId == 'typescript' ? '**/*.ts' : '**/*.js';
        const watcher = coc_nvim_1.workspace.createFileSystemWatcher(glob);
        this.disposables.push(watcher);
        watcher.onDidRename(e => {
            this.doRename(e.oldUri, e.newUri).catch(e => {
                client.logger.error(e.message);
            });
        }, null, this.disposables);
    }
    dispose() {
        coc_nvim_1.disposeAll(this.disposables);
    }
    doRename(oldResource, newResource) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (oldResource.scheme !== 'file' || newResource.scheme !== 'file') {
                return;
            }
            const targetFile = newResource.fsPath;
            const oldFile = oldResource.fsPath;
            yield coc_nvim_1.workspace.openResource(newResource.toString());
            // Make sure TS knows about file
            yield wait(100);
            let document = coc_nvim_1.workspace.getDocument(newResource.toString());
            if (!document)
                return;
            const edits = yield this.getEditsForFileRename(document.textDocument, oldFile, targetFile);
            if (!edits)
                return;
            if (yield this.promptUser(newResource)) {
                yield coc_nvim_1.workspace.applyEdit(edits);
            }
        });
    }
    promptUser(newResource) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const res = yield coc_nvim_1.workspace.nvim.call('coc#util#prompt_confirm', [`Update imports for moved file: ${newResource.fsPath} ?`]);
            return res == 1;
        });
    }
    getEditsForFileRename(document, oldFile, newFile) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.fileConfigurationManager.ensureConfigurationForDocument(document);
            const args = {
                oldFilePath: oldFile,
                newFilePath: newFile
            };
            const response = yield this.client.execute('getEditsForFileRename', args);
            if (!response || !response.body) {
                return;
            }
            const edits = [];
            for (const edit of response.body) {
                // Workaround for https://github.com/Microsoft/vscode/issues/52675
                if (edit.fileName.match(/[\/\\]node_modules[\/\\]/gi)) {
                    continue;
                }
                for (const change of edit.textChanges) {
                    if (change.newText.match(/\/node_modules\//gi)) {
                        continue;
                    }
                }
                edits.push(edit);
            }
            return typeConverters.WorkspaceEdit.fromFileCodeEdits(this.client, edits);
        });
    }
}
exports.default = UpdateImportsOnFileRenameHandler;
//# sourceMappingURL=updatePathOnRename.js.map