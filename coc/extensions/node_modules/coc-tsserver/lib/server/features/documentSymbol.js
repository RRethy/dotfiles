"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const PConst = tslib_1.__importStar(require("../protocol.const"));
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
const getSymbolKind = (kind) => {
    switch (kind) {
        case PConst.Kind.module:
            return vscode_languageserver_protocol_1.SymbolKind.Module;
        case PConst.Kind.class:
            return vscode_languageserver_protocol_1.SymbolKind.Class;
        case PConst.Kind.enum:
            return vscode_languageserver_protocol_1.SymbolKind.Enum;
        case PConst.Kind.interface:
            return vscode_languageserver_protocol_1.SymbolKind.Interface;
        case PConst.Kind.memberFunction:
            return vscode_languageserver_protocol_1.SymbolKind.Method;
        case PConst.Kind.memberVariable:
            return vscode_languageserver_protocol_1.SymbolKind.Property;
        case PConst.Kind.memberGetAccessor:
            return vscode_languageserver_protocol_1.SymbolKind.Property;
        case PConst.Kind.memberSetAccessor:
            return vscode_languageserver_protocol_1.SymbolKind.Property;
        case PConst.Kind.variable:
            return vscode_languageserver_protocol_1.SymbolKind.Variable;
        case PConst.Kind.const:
            return vscode_languageserver_protocol_1.SymbolKind.Variable;
        case PConst.Kind.localVariable:
            return vscode_languageserver_protocol_1.SymbolKind.Variable;
        case PConst.Kind.variable:
            return vscode_languageserver_protocol_1.SymbolKind.Variable;
        case PConst.Kind.constructSignature:
        case PConst.Kind.constructorImplementation:
        case PConst.Kind.function:
        case PConst.Kind.localFunction:
            return vscode_languageserver_protocol_1.SymbolKind.Function;
    }
    return vscode_languageserver_protocol_1.SymbolKind.Variable;
};
class TypeScriptDocumentSymbolProvider {
    constructor(client) {
        this.client = client;
    }
    provideDocumentSymbols(resource, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const filepath = this.client.toPath(resource.uri);
            if (!filepath)
                return [];
            const args = {
                file: filepath
            };
            try {
                const response = yield this.client.execute('navtree', args, token);
                if (response.body) {
                    // The root represents the file. Ignore this when showing in the UI
                    const tree = response.body;
                    if (tree.childItems) {
                        const result = new Array();
                        tree.childItems.forEach(item => TypeScriptDocumentSymbolProvider.convertNavTree(result, item));
                        return result;
                    }
                }
                return [];
            }
            catch (e) {
                return [];
            }
        });
    }
    static convertNavTree(bucket, item) {
        let shouldInclude = TypeScriptDocumentSymbolProvider.shouldInclueEntry(item);
        const children = new Set(item.childItems || []);
        for (const span of item.spans) {
            const range = typeConverters.Range.fromTextSpan(span);
            const symbolInfo = vscode_languageserver_protocol_1.DocumentSymbol.create(item.text, '', getSymbolKind(item.kind), range, range);
            symbolInfo.children = children.size > 0 ? [] : null;
            for (const child of children) {
                if (child.spans.some(span => !!containsRange(range, typeConverters.Range.fromTextSpan(span)))) {
                    const includedChild = TypeScriptDocumentSymbolProvider.convertNavTree(symbolInfo.children, child);
                    shouldInclude = shouldInclude || includedChild;
                    children.delete(child);
                }
            }
            if (shouldInclude) {
                bucket.push(symbolInfo);
            }
        }
        return shouldInclude;
    }
    static shouldInclueEntry(item) {
        if (item.kind === PConst.Kind.alias) {
            return false;
        }
        return !!(item.text &&
            item.text !== '<function>' &&
            item.text !== '<class>');
    }
}
exports.default = TypeScriptDocumentSymbolProvider;
function containsRange(range, otherRange) {
    if (otherRange.start.line < range.start.line || otherRange.end.line < range.start.line) {
        return false;
    }
    if (otherRange.start.line > range.end.line || otherRange.end.line > range.end.line) {
        return false;
    }
    if (otherRange.start.line === range.start.line && otherRange.start.character < range.start.character) {
        return false;
    }
    if (otherRange.end.line === range.end.line && otherRange.end.character > range.end.character) {
        return false;
    }
    return true;
}
//# sourceMappingURL=documentSymbol.js.map