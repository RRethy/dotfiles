"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const PConst = tslib_1.__importStar(require("../protocol.const"));
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
const baseCodeLensProvider_1 = require("./baseCodeLensProvider");
class TypeScriptImplementationsCodeLensProvider extends baseCodeLensProvider_1.TypeScriptBaseCodeLensProvider {
    resolveCodeLens(codeLens, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { uri } = codeLens.data;
            let filepath = this.client.toPath(uri);
            const args = typeConverters.Position.toFileLocationRequestArgs(filepath, codeLens.range.start);
            try {
                const response = yield this.client.execute('implementation', args, token);
                if (response && response.body) {
                    const locations = response.body
                        .map(reference => {
                        return {
                            uri: this.client.toResource(reference.file),
                            range: {
                                start: typeConverters.Position.fromLocation(reference.start),
                                end: {
                                    line: reference.start.line,
                                    character: 0
                                }
                            }
                        };
                    })
                        // Exclude original from implementations
                        .filter(location => !(location.uri.toString() === uri &&
                        location.range.start.line === codeLens.range.start.line &&
                        location.range.start.character ===
                            codeLens.range.start.character));
                    codeLens.command = this.getCommand(locations, codeLens);
                    return codeLens;
                }
            }
            catch (_a) {
                // noop
            }
            codeLens.command = {
                title: '0 implementations',
                command: ''
            };
            return codeLens;
        });
    }
    getCommand(locations, codeLens) {
        let { uri } = codeLens.data;
        return {
            title: this.getTitle(locations),
            command: locations.length ? 'editor.action.showReferences' : '',
            arguments: [uri, codeLens.range.start, locations]
        };
    }
    getTitle(locations) {
        return locations.length === 1 ? '1 implementation' : `${locations.length} implementations`;
    }
    extractSymbol(document, item, _parent) {
        switch (item.kind) {
            case PConst.Kind.interface:
                return super.getSymbolRange(document, item);
            case PConst.Kind.class:
            case PConst.Kind.memberFunction:
            case PConst.Kind.memberVariable:
            case PConst.Kind.memberGetAccessor:
            case PConst.Kind.memberSetAccessor:
                if (item.kindModifiers.match(/\babstract\b/g)) {
                    return super.getSymbolRange(document, item);
                }
                break;
        }
        return null;
    }
}
exports.default = TypeScriptImplementationsCodeLensProvider;
//# sourceMappingURL=implementationsCodeLens.js.map