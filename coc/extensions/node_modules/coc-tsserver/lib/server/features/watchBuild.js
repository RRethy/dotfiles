"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const fs_2 = require("../utils/fs");
const TSC = './node_modules/.bin/tsc';
const countRegex = /Found\s(\d+)\serror/;
const startRegex = /File\s+change\s+detected/;
const errorRegex = /^(.+):(\d+):(\d+)\s-\s(\w+)\s+[A-Za-z]+(\d+):\s+(.*)$/;
var TscStatus;
(function (TscStatus) {
    TscStatus[TscStatus["INIT"] = 0] = "INIT";
    TscStatus[TscStatus["COMPILING"] = 1] = "COMPILING";
    TscStatus[TscStatus["RUNNING"] = 2] = "RUNNING";
    TscStatus[TscStatus["ERROR"] = 3] = "ERROR";
})(TscStatus || (TscStatus = {}));
class WatchCommand {
    constructor() {
        this.id = 'tsserver.watchBuild';
    }
    setStatus(state) {
        let s = 'init';
        switch (state) {
            case TscStatus.COMPILING:
                s = 'compiling';
                break;
            case TscStatus.RUNNING:
                s = 'running';
                break;
            case TscStatus.ERROR:
                s = 'error';
                break;
        }
        let { nvim } = coc_nvim_1.workspace;
        nvim.setVar('tsc_status', s, true);
        nvim.command('redraws', true);
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let docs = coc_nvim_1.workspace.documents;
            let idx = docs.findIndex(doc => doc.uri.indexOf(TSC) !== -1);
            if (idx !== -1)
                return;
            let document = yield coc_nvim_1.workspace.document;
            let fsPath = vscode_uri_1.default.parse(document.uri).fsPath;
            let cwd = path_1.default.dirname(fsPath);
            let dir = fs_2.resolveRoot(cwd, ['node_modules']);
            if (dir) {
                let file = path_1.default.join(dir, 'node_modules/.bin/tsc');
                if (!fs_1.default.existsSync(file))
                    dir = null;
            }
            if (!dir) {
                coc_nvim_1.workspace.showMessage('typescript module not found!', 'error');
                return;
            }
            let configRoot = fs_2.resolveRoot(cwd, ['tsconfig.json']);
            if (!configRoot) {
                coc_nvim_1.workspace.showMessage('tsconfig.json not found!', 'error');
                return;
            }
            let configPath = path_1.default.relative(dir, path_1.default.join(configRoot, 'tsconfig.json'));
            let cmd = `${TSC} -p ${configPath} --watch true`;
            yield coc_nvim_1.workspace.nvim.call('coc#util#open_terminal', {
                keepfocus: 1,
                cwd: dir,
                cmd
            });
        });
    }
    onTerminalCreated(doc) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let items = [];
            let cwd = yield doc.getcwd();
            if (!cwd)
                return;
            this.setStatus(TscStatus.RUNNING);
            let parseLine = (line) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (startRegex.test(line)) {
                    this.setStatus(TscStatus.COMPILING);
                }
                else if (errorRegex.test(line)) {
                    let ms = line.match(errorRegex);
                    let lnum = Number(ms[2]) - 1;
                    let character = Number(ms[3]) - 1;
                    let range = vscode_languageserver_protocol_1.Range.create(lnum, character, lnum, character);
                    let uri = vscode_uri_1.default.file(path_1.default.join(cwd, ms[1])).toString();
                    let location = vscode_languageserver_protocol_1.Location.create(uri, range);
                    let item = {
                        location,
                        text: `[tsc ${ms[5]}] ${ms[6]}`,
                        type: /error/.test(ms[4]) ? 'E' : 'W'
                    };
                    items.push(item);
                }
                else if (countRegex.test(line)) {
                    let ms = line.match(countRegex);
                    if (ms[1] == '0' || items.length == 0) {
                        this.setStatus(TscStatus.RUNNING);
                        return;
                    }
                    this.setStatus(TscStatus.ERROR);
                    let qfItems = [];
                    for (let item of items) {
                        let o = yield coc_nvim_1.workspace.getQuickfixItem(item.location, item.text, item.type);
                        qfItems.push(o);
                    }
                    items = [];
                    let { nvim } = coc_nvim_1.workspace;
                    yield nvim.call('setqflist', [[], ' ', { title: 'Results of tsc', items: qfItems }]);
                    yield nvim.command('doautocmd User CocQuickfixChange');
                }
            });
            for (let line of doc.content.split('\n')) {
                parseLine(line); // tslint:disable-line
            }
            doc.onDocumentChange(e => {
                let { contentChanges } = e;
                for (let change of contentChanges) {
                    let lines = change.text.split('\n');
                    for (let line of lines) {
                        parseLine(line); // tslint:disable-line
                    }
                }
            });
        });
    }
}
class WatchProject {
    constructor(commandManager) {
        this.disposables = [];
        let cmd = new WatchCommand();
        commandManager.register(cmd);
        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            commandManager.unregister(cmd.id);
        }));
        coc_nvim_1.workspace.documents.forEach(doc => {
            let { uri } = doc;
            if (this.isTscBuffer(uri)) {
                cmd.onTerminalCreated(doc); // tslint:disable-line
            }
        });
        coc_nvim_1.workspace.onDidOpenTextDocument(doc => {
            let { uri } = doc;
            if (this.isTscBuffer(uri)) {
                cmd.onTerminalCreated(coc_nvim_1.workspace.getDocument(uri)); // tslint:disable-line
            }
        }, this, this.disposables);
        coc_nvim_1.workspace.onDidCloseTextDocument(doc => {
            let { uri } = doc;
            if (this.isTscBuffer(uri)) {
                coc_nvim_1.workspace.nvim.setVar('tsc_status', 'init', true);
                coc_nvim_1.workspace.nvim.command('redraws', true);
            }
        }, this, this.disposables);
    }
    isTscBuffer(uri) {
        return uri.startsWith('term:/') && uri.indexOf(TSC) !== -1;
    }
    dispose() {
        coc_nvim_1.disposeAll(this.disposables);
    }
}
exports.default = WatchProject;
//# sourceMappingURL=watchBuild.js.map