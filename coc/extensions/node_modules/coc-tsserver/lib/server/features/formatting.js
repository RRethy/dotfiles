"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const coc_nvim_1 = require("coc.nvim");
const semicolon_1 = require("../utils/semicolon");
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
class TypeScriptFormattingProvider {
    constructor(client, formattingOptionsManager) {
        this.client = client;
        this.formattingOptionsManager = formattingOptionsManager;
    }
    doFormat(document, options, args, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.formattingOptionsManager.ensureConfigurationOptions(document.languageId, options.insertSpaces, options.tabSize);
            try {
                const response = yield this.client.execute('format', args, token);
                if (response.body) {
                    let edits = response.body.map(typeConverters.TextEdit.fromCodeEdit);
                    if (this.formattingOptionsManager.removeSemicolons(document.languageId)) {
                        return semicolon_1.removeSemicolon(document, edits);
                    }
                    return edits;
                }
            }
            catch (_a) {
                // noop
            }
            return [];
        });
    }
    provideDocumentRangeFormattingEdits(document, range, options, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const filepath = this.client.toPath(document.uri);
            if (!filepath)
                return [];
            const args = {
                file: filepath,
                line: range.start.line + 1,
                offset: range.start.character + 1,
                endLine: range.end.line + 1,
                endOffset: range.end.character + 1
            };
            return this.doFormat(document, options, args, token);
        });
    }
    provideDocumentFormattingEdits(document, options, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const filepath = this.client.toPath(document.uri);
            if (!filepath)
                return [];
            const args = {
                file: filepath,
                line: 1,
                offset: 1,
                endLine: document.lineCount + 1,
                endOffset: 1
            };
            return this.doFormat(document, options, args, token);
        });
    }
    provideOnTypeFormattingEdits(document, position, ch, options, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.client.configuration.formatOnType) {
                return;
            }
            const file = this.client.toPath(document.uri);
            if (!file) {
                return [];
            }
            yield this.formattingOptionsManager.ensureConfigurationOptions(document.languageId, options.insertSpaces, options.tabSize);
            const doc = coc_nvim_1.workspace.getDocument(document.uri);
            const args = Object.assign({}, typeConverters.Position.toFileLocationRequestArgs(file, position), { key: ch });
            try {
                const { body } = yield this.client.execute('formatonkey', args, token);
                const edits = body;
                const result = [];
                if (!edits) {
                    return result;
                }
                for (const edit of edits) {
                    const textEdit = typeConverters.TextEdit.fromCodeEdit(edit);
                    const range = textEdit.range;
                    // Work around for https://github.com/Microsoft/TypeScript/issues/6700.
                    // Check if we have an edit at the beginning of the line which only removes white spaces and leaves
                    // an empty line. Drop those edits
                    if (range.start.character === 0 &&
                        range.start.line === range.end.line &&
                        textEdit.newText === '') {
                        const lText = doc.getline(range.start.line);
                        // If the edit leaves something on the line keep the edit (note that the end character is exclusive).
                        // Keep it also if it removes something else than whitespace
                        if (lText.trim().length > 0 || lText.length > range.end.character) {
                            result.push(textEdit);
                        }
                    }
                    else {
                        result.push(textEdit);
                    }
                }
                return result;
            }
            catch (_a) {
                // noop
            }
            return [];
        });
    }
}
exports.default = TypeScriptFormattingProvider;
//# sourceMappingURL=formatting.js.map