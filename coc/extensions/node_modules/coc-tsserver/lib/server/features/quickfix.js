"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const api_1 = tslib_1.__importDefault(require("../utils/api"));
const codeAction_1 = require("../utils/codeAction");
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
class ApplyCodeActionCommand {
    constructor(client) {
        this.client = client;
        this.id = ApplyCodeActionCommand.ID;
    }
    execute(action) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return codeAction_1.applyCodeActionCommands(this.client, action);
        });
    }
}
ApplyCodeActionCommand.ID = '_typescript.applyCodeActionCommand';
class ApplyFixAllCodeAction {
    constructor(client) {
        this.client = client;
        this.id = ApplyFixAllCodeAction.ID;
    }
    execute(file, tsAction) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!tsAction.fixId) {
                return;
            }
            const args = {
                scope: {
                    type: 'file',
                    args: { file }
                },
                fixId: tsAction.fixId
            };
            try {
                const { body } = yield this.client.execute('getCombinedCodeFix', args);
                if (!body) {
                    return;
                }
                const edit = typeConverters.WorkspaceEdit.fromFileCodeEdits(this.client, body.changes);
                yield coc_nvim_1.workspace.applyEdit(edit);
                const token = vscode_languageserver_protocol_1.CancellationToken.None;
                const { commands } = body;
                if (commands && commands.length) {
                    for (const command of commands) {
                        yield this.client.execute('applyCodeActionCommand', { command }, token);
                    }
                }
            }
            catch (_a) {
                // noop
            }
        });
    }
}
ApplyFixAllCodeAction.ID = '_typescript.applyFixAllCodeAction';
/**
 * Unique set of diagnostics keyed on diagnostic range and error code.
 */
class DiagnosticsSet {
    constructor(_values) {
        this._values = _values;
    }
    static from(diagnostics) {
        const values = new Map();
        for (const diagnostic of diagnostics) {
            values.set(DiagnosticsSet.key(diagnostic), diagnostic);
        }
        return new DiagnosticsSet(values);
    }
    static key(diagnostic) {
        const { start, end } = diagnostic.range;
        return `${diagnostic.code}-${start.line},${start.character}-${end.line},${end.character}`;
    }
    get values() {
        return this._values.values();
    }
}
class SupportedCodeActionProvider {
    constructor(client) {
        this.client = client;
    }
    getFixableDiagnosticsForContext(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const supportedActions = yield this.supportedCodeActions;
            const fixableDiagnostics = DiagnosticsSet.from(context.diagnostics.filter(diagnostic => supportedActions.has(+diagnostic.code)));
            return Array.from(fixableDiagnostics.values);
        });
    }
    get supportedCodeActions() {
        if (!this._supportedCodeActions) {
            this._supportedCodeActions = this.client
                .execute('getSupportedCodeFixes', null, undefined)
                .then(response => response.body || [])
                .then(codes => codes.map(code => +code).filter(code => !isNaN(code)))
                .then(codes => new Set(codes));
        }
        return Promise.resolve(this._supportedCodeActions);
    }
}
class TypeScriptQuickFixProvider {
    constructor(client, diagnosticsManager, bufferSyncSupport) {
        this.client = client;
        this.diagnosticsManager = diagnosticsManager;
        this.bufferSyncSupport = bufferSyncSupport;
        coc_nvim_1.commands.register(new ApplyCodeActionCommand(client));
        coc_nvim_1.commands.register(new ApplyFixAllCodeAction(client));
        this.supportedCodeActionProvider = new SupportedCodeActionProvider(client);
    }
    provideCodeActions(document, _range, context, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.client.apiVersion.gte(api_1.default.v213)) {
                return [];
            }
            const file = this.client.toPath(document.uri);
            if (!file) {
                return [];
            }
            const fixableDiagnostics = yield this.supportedCodeActionProvider.getFixableDiagnosticsForContext(context);
            if (!fixableDiagnostics.length) {
                return [];
            }
            if (this.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {
                return [];
            }
            const results = [];
            for (const diagnostic of fixableDiagnostics) {
                results.push(...(yield this.getFixesForDiagnostic(document, file, diagnostic, token)));
            }
            return results;
        });
    }
    getFixesForDiagnostic(document, file, diagnostic, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const args = Object.assign({}, typeConverters.Range.toFileRangeRequestArgs(file, diagnostic.range), { errorCodes: [+diagnostic.code] });
            const codeFixesResponse = yield this.client.execute('getCodeFixes', args, token);
            if (codeFixesResponse.body) {
                const results = [];
                for (const tsCodeFix of codeFixesResponse.body) {
                    results.push(...(yield this.getAllFixesForTsCodeAction(document, file, diagnostic, tsCodeFix)));
                }
                return results;
            }
            return [];
        });
    }
    getAllFixesForTsCodeAction(document, file, diagnostic, tsAction) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const singleFix = this.getSingleFixForTsCodeAction(diagnostic, tsAction);
            const fixAll = yield this.getFixAllForTsCodeAction(document, file, diagnostic, tsAction);
            return fixAll ? [singleFix, fixAll] : [singleFix];
        });
    }
    getSingleFixForTsCodeAction(diagnostic, tsAction) {
        const codeAction = {
            title: tsAction.description,
            kind: vscode_languageserver_protocol_1.CodeActionKind.QuickFix
        };
        codeAction.edit = codeAction_1.getEditForCodeAction(this.client, tsAction);
        codeAction.diagnostics = [diagnostic];
        if (tsAction.commands) {
            codeAction.command = {
                command: ApplyCodeActionCommand.ID,
                arguments: [tsAction],
                title: tsAction.description
            };
        }
        return codeAction;
    }
    getFixAllForTsCodeAction(document, file, diagnostic, tsAction) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!tsAction.fixId || !this.client.apiVersion.gte(api_1.default.v270)) {
                return undefined;
            }
            // Make sure there are multiple diagnostics of the same type in the file
            if (!this.diagnosticsManager
                .getDiagnostics(document.uri)
                .some(x => x.code === diagnostic.code && x !== diagnostic)) {
                return;
            }
            const action = {
                title: tsAction.fixAllDescription || 'Fix all in file',
                kind: vscode_languageserver_protocol_1.CodeActionKind.QuickFix
            };
            action.diagnostics = [diagnostic];
            action.command = {
                command: ApplyFixAllCodeAction.ID,
                arguments: [file, tsAction],
                title: ''
            };
            return action;
        });
    }
}
exports.default = TypeScriptQuickFixProvider;
//# sourceMappingURL=quickfix.js.map