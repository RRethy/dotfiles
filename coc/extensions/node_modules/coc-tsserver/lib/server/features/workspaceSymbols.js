"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
function getSymbolKind(item) {
    switch (item.kind) {
        case 'method':
            return vscode_languageserver_protocol_1.SymbolKind.Method;
        case 'enum':
            return vscode_languageserver_protocol_1.SymbolKind.Enum;
        case 'function':
            return vscode_languageserver_protocol_1.SymbolKind.Function;
        case 'class':
            return vscode_languageserver_protocol_1.SymbolKind.Class;
        case 'interface':
            return vscode_languageserver_protocol_1.SymbolKind.Interface;
        case 'var':
            return vscode_languageserver_protocol_1.SymbolKind.Variable;
        default:
            return vscode_languageserver_protocol_1.SymbolKind.Variable;
    }
}
class TypeScriptWorkspaceSymbolProvider {
    constructor(client, languageIds) {
        this.client = client;
        this.languageIds = languageIds;
    }
    provideWorkspaceSymbols(search, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const uri = this.getUri();
            if (!uri)
                return [];
            const filepath = this.client.toPath(uri);
            if (!filepath)
                return [];
            const args = {
                file: filepath,
                searchValue: search
            };
            const response = yield this.client.execute('navto', args, token);
            if (!response.body)
                return [];
            const result = [];
            for (const item of response.body) {
                if (!item.containerName && item.kind === 'alias') {
                    continue;
                }
                const label = TypeScriptWorkspaceSymbolProvider.getLabel(item);
                const range = {
                    start: typeConverters.Position.fromLocation(item.start),
                    end: typeConverters.Position.fromLocation(item.end),
                };
                const symbolInfo = vscode_languageserver_protocol_1.SymbolInformation.create(label, getSymbolKind(item), range, this.client.toResource(item.file));
                result.push(symbolInfo);
            }
            return result;
        });
    }
    static getLabel(item) {
        let label = item.name;
        if (item.kind === 'method' || item.kind === 'function') {
            label += '()';
        }
        return label;
    }
    getUri() {
        // typescript wants to have a resource even when asking
        // general questions so we check the active editor. If this
        // doesn't match we take the first TS document.
        const documents = coc_nvim_1.workspace.textDocuments;
        for (const document of documents) {
            if (this.languageIds.indexOf(document.languageId) >= 0) {
                return document.uri;
            }
        }
        return undefined;
    }
}
exports.default = TypeScriptWorkspaceSymbolProvider;
//# sourceMappingURL=workspaceSymbols.js.map