"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
const PConst = tslib_1.__importStar(require("../protocol.const"));
const api_1 = tslib_1.__importDefault(require("../utils/api"));
const codeAction_1 = require("../utils/codeAction");
const completionItem_1 = require("../utils/completionItem");
const Previewer = tslib_1.__importStar(require("../utils/previewer"));
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
class ApplyCompletionCodeActionCommand {
    constructor(client) {
        this.client = client;
        this.id = ApplyCompletionCodeActionCommand.ID;
    }
    // apply code action on complete
    execute(codeActions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (codeActions.length === 0) {
                return;
            }
            if (codeActions.length === 1) {
                yield codeAction_1.applyCodeAction(this.client, codeActions[0]);
                return;
            }
            const idx = yield coc_nvim_1.workspace.showQuickpick(codeActions.map(o => o.description), 'Select code action to apply');
            if (idx < 0)
                return;
            const action = codeActions[idx];
            yield codeAction_1.applyCodeAction(this.client, action);
            return;
        });
    }
}
ApplyCompletionCodeActionCommand.ID = '_typescript.applyCompletionCodeAction';
class TypeScriptCompletionItemProvider {
    constructor(client, typingsStatus, fileConfigurationManager, languageId) {
        this.client = client;
        this.typingsStatus = typingsStatus;
        this.fileConfigurationManager = fileConfigurationManager;
        this.noSemicolons = false;
        this.setCompleteOption(languageId);
        coc_nvim_1.commands.register(new ApplyCompletionCodeActionCommand(this.client));
        coc_nvim_1.workspace.onDidChangeConfiguration(_e => {
            this.setCompleteOption(languageId);
        });
    }
    setCompleteOption(languageId) {
        this.completeOption = this.fileConfigurationManager.getCompleteOptions(languageId);
        this.noSemicolons = this.fileConfigurationManager.removeSemicolons(languageId);
    }
    /**
     * Get completionItems
     *
     * @public
     * @param {TextDocument} document
     * @param {Position} position
     * @param {CancellationToken} token
     * @param {string} triggerCharacter
     * @returns {Promise<CompletionItem[]>}
     */
    provideCompletionItems(document, position, token, context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.typingsStatus.isAcquiringTypings) {
                coc_nvim_1.workspace.showMessage('Acquiring typings...', 'warning');
                return null;
            }
            let { uri } = document;
            const file = this.client.toPath(document.uri);
            if (!file)
                return null;
            let preText = document.getText({
                start: { line: position.line, character: 0 },
                end: position
            });
            let { triggerCharacter, option } = context;
            if (!this.shouldTrigger(triggerCharacter, preText, option)) {
                return null;
            }
            const { completeOption } = this;
            const doc = coc_nvim_1.workspace.getDocument(uri);
            const args = Object.assign({}, typeConverters.Position.toFileLocationRequestArgs(file, position), { includeExternalModuleExports: completeOption.autoImports, includeInsertTextCompletions: true, triggerCharacter: this.getTsTriggerCharacter(context) });
            let msg;
            let isNewIdentifierLocation = true;
            if (this.client.apiVersion.gte(api_1.default.v300)) {
                try {
                    const response = yield this.client.execute('completionInfo', args, token);
                    if (response.type !== 'response' || !response.body) {
                        return null;
                    }
                    isNewIdentifierLocation = response.body.isNewIdentifierLocation;
                    msg = response.body.entries;
                }
                catch (e) {
                    if (e.message == 'No content available.') {
                        return null;
                    }
                    throw e;
                }
            }
            else {
                const response = yield this.client.execute('completions', args, token);
                msg = response.body;
                if (!msg)
                    return null;
            }
            const completionItems = [];
            for (const element of msg) {
                if (shouldExcludeCompletionEntry(element, completeOption)) {
                    continue;
                }
                const item = completionItem_1.convertCompletionEntry(element, uri, position, completeOption.completeFunctionCalls, isNewIdentifierLocation);
                completionItems.push(item);
            }
            let startcol = null;
            if (triggerCharacter == '@' && !doc.isWord('@')) {
                startcol = option.col - 1;
            }
            let res = {
                startcol,
                isIncomplete: false,
                items: completionItems
            };
            return res;
        });
    }
    getTsTriggerCharacter(context) {
        // Workaround for https://github.com/Microsoft/TypeScript/issues/27321
        if (context.triggerCharacter === '@'
            && this.client.apiVersion.gte(api_1.default.v310) && this.client.apiVersion.lt(api_1.default.v320)) {
            return undefined;
        }
        return context.triggerCharacter;
    }
    /**
     * Resolve complete item, could have documentation added
     *
     * @public
     * @param {CompletionItem} item
     * @param {CancellationToken} token
     * @returns {Promise<CompletionItem>}
     */
    resolveCompletionItem(item, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (item == null)
                return undefined;
            let { uri, position, source } = item.data;
            const filepath = this.client.toPath(uri);
            if (!filepath)
                return undefined;
            let document = coc_nvim_1.workspace.getDocument(uri);
            if (!document)
                return undefined;
            const args = Object.assign({}, typeConverters.Position.toFileLocationRequestArgs(filepath, position), { entryNames: [
                    source
                        ? { name: item.label, source }
                        : item.label
                ] });
            let response;
            try {
                response = yield this.client.execute('completionEntryDetails', args, token);
            }
            catch (_a) {
                return item;
            }
            const details = response.body;
            if (!details || !details.length || !details[0]) {
                return item;
            }
            const detail = details[0];
            item.detail = detail.displayParts.length
                ? Previewer.plain(detail.displayParts)
                : undefined;
            item.documentation = this.getDocumentation(detail);
            const { command, additionalTextEdits } = this.getCodeActions(detail, filepath);
            if (command)
                item.command = command;
            item.additionalTextEdits = additionalTextEdits;
            if (detail && item.insertTextFormat == vscode_languageserver_protocol_1.InsertTextFormat.Snippet) {
                const shouldCompleteFunction = yield this.isValidFunctionCompletionContext(filepath, position, token);
                if (shouldCompleteFunction) {
                    this.createSnippetOfFunctionCall(item, detail);
                }
            }
            return item;
        });
    }
    getCodeActions(detail, filepath) {
        if (!detail.codeActions || !detail.codeActions.length) {
            return {};
        }
        // Try to extract out the additionalTextEdits for the current file.
        // Also check if we still have to apply other workspace edits
        const additionalTextEdits = [];
        let hasReaminingCommandsOrEdits = false;
        for (const tsAction of detail.codeActions) {
            if (tsAction.commands) {
                hasReaminingCommandsOrEdits = true;
            }
            // Convert all edits in the current file using `additionalTextEdits`
            if (tsAction.changes) {
                for (const change of tsAction.changes) {
                    if (change.fileName === filepath) {
                        additionalTextEdits.push(...change.textChanges.map(typeConverters.TextEdit.fromCodeEdit));
                    }
                    else {
                        hasReaminingCommandsOrEdits = true;
                    }
                }
            }
        }
        let command = null;
        if (hasReaminingCommandsOrEdits) {
            // Create command that applies all edits not in the current file.
            command = {
                title: '',
                command: ApplyCompletionCodeActionCommand.ID,
                arguments: [
                    detail.codeActions.map((x) => ({
                        commands: x.commands,
                        description: x.description,
                        changes: x.changes.filter(x => x.fileName !== filepath)
                    }))
                ]
            };
        }
        if (additionalTextEdits.length && this.noSemicolons) {
            // remove comma
            additionalTextEdits.forEach(o => {
                o.newText = o.newText.replace(/;/g, '');
            });
        }
        return {
            command,
            additionalTextEdits: additionalTextEdits.length
                ? additionalTextEdits
                : undefined
        };
    }
    shouldTrigger(triggerCharacter, pre, option) {
        if (triggerCharacter === '.') {
            if (pre.match(/[\s\.'"]\.$/)) {
                return false;
            }
        }
        else if (triggerCharacter === '@') {
            // trigger in string
            if (option.synname && /string/i.test(option.synname)) {
                return true;
            }
            // make sure we are in something that looks like the start of a jsdoc comment
            if (!pre.match(/^\s*\*[ ]?@/) && !pre.match(/\/\*\*+[ ]?@/)) {
                return false;
            }
        }
        else if (triggerCharacter === '<') {
            return this.client.apiVersion.gte(api_1.default.v290);
        }
        return true;
    }
    // complete item documentation
    getDocumentation(detail) {
        let documentation = '';
        if (detail.source) {
            const importPath = `'${Previewer.plain(detail.source)}'`;
            const autoImportLabel = `Auto import from ${importPath}`;
            documentation += `${autoImportLabel}\n`;
        }
        let parts = [
            Previewer.plain(detail.documentation),
            Previewer.tagsMarkdownPreview(detail.tags)
        ];
        parts = parts.filter(s => s && s.trim() != '');
        documentation += parts.join('\n\n');
        if (documentation.length) {
            return {
                kind: vscode_languageserver_protocol_1.MarkupKind.Markdown,
                value: documentation
            };
        }
        return undefined;
    }
    createSnippetOfFunctionCall(item, detail) {
        let { displayParts } = detail;
        let snippet = (item.insertText || item.label) + '('; // tslint:disable-line
        const parameterListParts = completionItem_1.getParameterListParts(displayParts);
        let { parts, hasOptionalParameters } = parameterListParts;
        let idx = 1;
        if (parts.length == 0 && hasOptionalParameters) {
            item.insertText = snippet + '${1})$0';
            return;
        }
        for (let part of parts) {
            snippet += '${' + idx + ':' + part.text + '}'; // tslint:disable-line
            if (idx == parts.length) {
                if (hasOptionalParameters)
                    snippet += '${' + (idx + 1) + '}'; // tslint:disable-line
            }
            else {
                snippet += ', ';
            }
            idx = idx + 1;
        }
        snippet += ')$0';
        // tslint:disable-next-line:deprecation
        item.insertText = snippet;
    }
    isValidFunctionCompletionContext(filepath, position, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Workaround for https://github.com/Microsoft/TypeScript/issues/12677
            // Don't complete function calls inside of destructive assigments or imports
            try {
                const args = typeConverters.Position.toFileLocationRequestArgs(filepath, position);
                const response = yield this.client.execute('quickinfo', args, token);
                if (response.type !== 'response') {
                    return true;
                }
                const { body } = response;
                switch (body && body.kind) {
                    case 'var':
                    case 'let':
                    case 'const':
                    case 'alias':
                        return false;
                    default:
                        return true;
                }
            }
            catch (e) {
                return true;
            }
        });
    }
}
TypeScriptCompletionItemProvider.triggerCharacters = ['.', '"', '\'', '/', '@', '<'];
exports.default = TypeScriptCompletionItemProvider;
function shouldExcludeCompletionEntry(element, completionConfiguration) {
    return ((!completionConfiguration.names && element.kind === PConst.Kind.warning)
        || (!completionConfiguration.paths &&
            (element.kind === PConst.Kind.directory || element.kind === PConst.Kind.script || element.kind === PConst.Kind.externalModuleName))
        || (!completionConfiguration.autoImports && element.hasAction));
}
//# sourceMappingURL=completionItemProvider.js.map