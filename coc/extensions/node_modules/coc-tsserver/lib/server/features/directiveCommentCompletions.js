"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
const directives = [
    {
        value: '@ts-check',
        description: 'Enables semantic checking in a JavaScript file. Must be at the top of a file.'
    },
    {
        value: '@ts-nocheck',
        description: 'Disables semantic checking in a JavaScript file. Must be at the top of a file.'
    },
    {
        value: '@ts-ignore',
        description: 'Suppresses @ts-check errors on the next line of a file.'
    }
];
class DirectiveCommentCompletionProvider {
    constructor(client) {
        this.client = client;
    }
    provideCompletionItems(document, position, _token, context) {
        if (context.triggerCharacter != '@') {
            return [];
        }
        const file = this.client.toPath(document.uri);
        if (!file) {
            return [];
        }
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        const line = doc.getline(position.line);
        const prefix = line.slice(0, position.character);
        const match = prefix.match(/^\s*\/\/+\s?(@[a-zA-Z\-]*)?$/);
        if (match) {
            let items = directives.map(directive => {
                const item = vscode_languageserver_protocol_1.CompletionItem.create(directive.value);
                item.kind = vscode_languageserver_protocol_1.CompletionItemKind.Snippet;
                item.detail = directive.description;
                item.textEdit = {
                    range: vscode_languageserver_protocol_1.Range.create(position.line, Math.max(0, position.character - (match[1] ? match[1].length : 0)), position.line, position.character),
                    newText: directive.value
                };
                return item;
            });
            let res = {
                isIncomplete: false,
                items
            };
            res.startcol = doc.fixStartcol(position, ['@']);
            return res;
        }
        return [];
    }
}
exports.default = DirectiveCommentCompletionProvider;
//# sourceMappingURL=directiveCommentCompletions.js.map