"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const api_1 = tslib_1.__importDefault(require("../utils/api"));
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
class TypeScriptRenameProvider {
    constructor(client) {
        this.client = client;
    }
    prepareRename(document, position, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.execRename(document, position, token);
            if (!response || response.type !== 'response' || !response.body) {
                return null;
            }
            const renameInfo = response.body.info;
            if (!renameInfo.canRename) {
                return Promise.reject(new Error('Invalid location for rename.'));
            }
            if (this.client.apiVersion.gte(api_1.default.v310)) {
                const triggerSpan = renameInfo.triggerSpan;
                if (triggerSpan) {
                    const range = typeConverters.Range.fromTextSpan(triggerSpan);
                    return range;
                }
            }
            return null;
        });
    }
    provideRenameEdits(document, position, newName, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.execRename(document, position, token);
            if (!response || response.type !== 'response' || !response.body) {
                return null;
            }
            const renameInfo = response.body.info;
            if (!renameInfo.canRename) {
                return Promise.reject(new Error('Invalid location for rename.'));
            }
            if (this.client.apiVersion.gte(api_1.default.v310)) {
                if (renameInfo.fileToRename) {
                    const edits = yield this.renameFile(renameInfo.fileToRename, newName, token);
                    if (edits) {
                        return edits;
                    }
                    else {
                        return Promise.reject(new Error('An error occurred while renaming file'));
                    }
                }
            }
            return this.toWorkspaceEdit(response.body.locs, newName);
        });
    }
    execRename(document, position, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const file = this.client.toPath(document.uri);
            if (!file)
                return undefined;
            const args = Object.assign({}, typeConverters.Position.toFileLocationRequestArgs(file, position), { findInStrings: false, findInComments: false });
            return this.client.execute('rename', args, token);
        });
    }
    toWorkspaceEdit(locations, newName) {
        let changes = {};
        for (const spanGroup of locations) {
            const uri = this.client.toResource(spanGroup.file);
            if (uri) {
                changes[uri] = [];
                for (const textSpan of spanGroup.locs) {
                    changes[uri].push({
                        range: typeConverters.Range.fromTextSpan(textSpan),
                        newText: newName
                    });
                }
            }
        }
        return { changes };
    }
    renameFile(fileToRename, newName, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Make sure we preserve file exension if none provided
            if (!path_1.default.extname(newName)) {
                newName += path_1.default.extname(fileToRename);
            }
            const dirname = path_1.default.dirname(fileToRename);
            const newFilePath = path_1.default.join(dirname, newName);
            const args = {
                file: fileToRename,
                oldFilePath: fileToRename,
                newFilePath
            };
            const response = yield this.client.execute('getEditsForFileRename', args, token);
            if (response.type !== 'response' || !response.body) {
                return undefined;
            }
            const edits = typeConverters.WorkspaceEdit.fromFileCodeEdits(this.client, response.body);
            edits.documentChanges = edits.documentChanges || [];
            edits.documentChanges.push({
                kind: 'rename',
                oldUri: vscode_uri_1.default.file(fileToRename).toString(),
                newUri: vscode_uri_1.default.file(newFilePath).toString(),
                options: {
                    overwrite: false,
                    ignoreIfExists: true
                }
            });
            return edits;
        });
    }
}
exports.default = TypeScriptRenameProvider;
//# sourceMappingURL=rename.js.map