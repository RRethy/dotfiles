"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const coc_nvim_1 = require("coc.nvim");
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
class ApplyRefactoringCommand {
    constructor(client) {
        this.client = client;
        this.id = ApplyRefactoringCommand.ID;
    }
    execute(document, file, refactor, action, range) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const args = Object.assign({}, typeConverters.Range.toFileRangeRequestArgs(file, range), { refactor,
                action });
            const response = yield this.client.execute('getEditsForRefactor', args);
            const body = response && response.body;
            if (!body || !body.edits.length) {
                return false;
            }
            const workspaceEdit = yield this.toWorkspaceEdit(body);
            if (!(yield coc_nvim_1.workspace.applyEdit(workspaceEdit))) {
                return false;
            }
            const renameLocation = body.renameLocation;
            if (renameLocation) {
                coc_nvim_1.commands.executeCommand('editor.action.rename', document.uri, typeConverters.Position.fromLocation(renameLocation));
            }
            return true;
        });
    }
    toWorkspaceEdit(body) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            for (const edit of body.edits) {
                yield coc_nvim_1.workspace.createFile(edit.fileName, { ignoreIfExists: true });
            }
            let workspaceEdit = typeConverters.WorkspaceEdit.fromFileCodeEdits(this.client, body.edits);
            return workspaceEdit;
        });
    }
}
ApplyRefactoringCommand.ID = '_typescript.applyRefactoring';
class SelectRefactorCommand {
    constructor(doRefactoring) {
        this.doRefactoring = doRefactoring;
        this.id = SelectRefactorCommand.ID;
    }
    execute(document, file, info, range) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { actions } = info;
            const idx = actions.length == 1 ? 0 : yield coc_nvim_1.workspace.showQuickpick(actions.map(action => action.description || action.name));
            if (idx == -1)
                return false;
            let label = info.actions[idx].name;
            if (!label)
                return false;
            return this.doRefactoring.execute(document, file, info.name, label, range);
        });
    }
}
SelectRefactorCommand.ID = '_typescript.selectRefactoring';
class TypeScriptRefactorProvider {
    constructor(client, formattingOptionsManager) {
        this.client = client;
        this.formattingOptionsManager = formattingOptionsManager;
        const doRefactoringCommand = coc_nvim_1.commands.register(new ApplyRefactoringCommand(this.client));
        coc_nvim_1.commands.register(new SelectRefactorCommand(doRefactoringCommand));
    }
    provideCodeActions(document, range, context, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.shouldTrigger(context)) {
                return undefined;
            }
            const file = this.client.toPath(document.uri);
            if (!file)
                return undefined;
            yield this.formattingOptionsManager.ensureConfigurationForDocument(document);
            const args = typeConverters.Range.toFileRangeRequestArgs(file, range);
            let response;
            try {
                response = yield this.client.execute('getApplicableRefactors', args, token);
                if (!response || !response.body) {
                    return undefined;
                }
            }
            catch (_a) {
                return undefined;
            }
            return this.convertApplicableRefactors(response.body, document, file, range);
        });
    }
    convertApplicableRefactors(body, document, file, rangeOrSelection) {
        const actions = [];
        for (const info of body) {
            if (!info.inlineable) {
                const codeAction = {
                    title: info.description,
                    kind: vscode_languageserver_protocol_1.CodeActionKind.Refactor
                };
                codeAction.command = {
                    title: info.description,
                    command: SelectRefactorCommand.ID,
                    arguments: [document, file, info, rangeOrSelection]
                };
                actions.push(codeAction);
            }
            else {
                for (const action of info.actions) {
                    actions.push(this.refactorActionToCodeAction(action, document, file, info, rangeOrSelection));
                }
            }
        }
        return actions;
    }
    refactorActionToCodeAction(action, document, file, info, rangeOrSelection) {
        const codeAction = {
            title: action.description,
            kind: TypeScriptRefactorProvider.getKind(action)
        };
        codeAction.command = {
            title: action.description,
            command: ApplyRefactoringCommand.ID,
            arguments: [document, file, info.name, action.name, rangeOrSelection]
        };
        return codeAction;
    }
    shouldTrigger(context) {
        if (context.only &&
            context.only.indexOf(vscode_languageserver_protocol_1.CodeActionKind.Refactor) == -1) {
            return false;
        }
        return true;
    }
    static getKind(refactor) {
        if (refactor.name.startsWith('function_')) {
            return TypeScriptRefactorProvider.extractFunctionKind;
        }
        else if (refactor.name.startsWith('constant_')) {
            return TypeScriptRefactorProvider.extractConstantKind;
        }
        else if (refactor.name.startsWith('Move')) {
            return TypeScriptRefactorProvider.moveKind;
        }
        return vscode_languageserver_protocol_1.CodeActionKind.Refactor;
    }
}
TypeScriptRefactorProvider.extractFunctionKind = vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract + '.function';
TypeScriptRefactorProvider.extractConstantKind = vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract + '.constant';
TypeScriptRefactorProvider.moveKind = vscode_languageserver_protocol_1.CodeActionKind.Refactor + '.move';
TypeScriptRefactorProvider.metadata = {
    providedCodeActionKinds: [vscode_languageserver_protocol_1.CodeActionKind.Refactor]
};
exports.default = TypeScriptRefactorProvider;
//# sourceMappingURL=refactor.js.map