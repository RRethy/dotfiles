"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const PConst = tslib_1.__importStar(require("../protocol.const"));
function convertCompletionEntry(tsEntry, uri, position, useCodeSnippetsOnMethodSuggest, isNewIdentifierLocation) {
    let label = tsEntry.name;
    let sortText = tsEntry.sortText;
    if (tsEntry.isRecommended) {
        // Make sure isRecommended property always comes first
        // https://github.com/Microsoft/vscode/issues/40325
        sortText = '\0' + sortText;
    }
    else if (tsEntry.source) {
        // De-prioritze auto-imports
        // https://github.com/Microsoft/vscode/issues/40311
        sortText = '\uffff' + sortText;
    }
    else {
        sortText = tsEntry.sortText;
    }
    let kind = convertKind(tsEntry.kind);
    let insertTextFormat = (useCodeSnippetsOnMethodSuggest &&
        (kind === vscode_languageserver_protocol_1.CompletionItemKind.Function ||
            kind === vscode_languageserver_protocol_1.CompletionItemKind.Method)) ? vscode_languageserver_protocol_1.InsertTextFormat.Snippet : vscode_languageserver_protocol_1.InsertTextFormat.PlainText;
    let insertText = tsEntry.insertText;
    let document = coc_nvim_1.workspace.getDocument(uri);
    let preText = document.getline(position.line).slice(0, position.character);
    const isInValidCommitCharacterContext = preText.match(/(^|[a-z_$\(\)\[\]\{\}]|[^.]\.)\s*$/ig) !== null;
    let commitCharacters = getCommitCharacters(tsEntry, { isNewIdentifierLocation, isInValidCommitCharacterContext, useCodeSnippetsOnMethodSuggest });
    let optional = tsEntry.kindModifiers && tsEntry.kindModifiers.match(/\boptional\b/);
    let textEdit = null;
    if (tsEntry.replacementSpan) {
        let { start, end } = tsEntry.replacementSpan;
        if (start.line == end.line) {
            textEdit = {
                range: vscode_languageserver_protocol_1.Range.create(start.line - 1, start.offset - 1, end.line - 1, end.offset - 1),
                newText: insertText || label
            };
        }
    }
    return {
        label,
        insertText,
        textEdit,
        kind,
        insertTextFormat,
        sortText,
        commitCharacters,
        data: {
            uri,
            optional,
            position,
            source: tsEntry.source || ''
        }
    };
}
exports.convertCompletionEntry = convertCompletionEntry;
function convertKind(kind) {
    switch (kind) {
        case PConst.Kind.primitiveType:
        case PConst.Kind.keyword:
            return vscode_languageserver_protocol_1.CompletionItemKind.Keyword;
        case PConst.Kind.const:
            return vscode_languageserver_protocol_1.CompletionItemKind.Constant;
        case PConst.Kind.let:
        case PConst.Kind.variable:
        case PConst.Kind.localVariable:
        case PConst.Kind.alias:
            return vscode_languageserver_protocol_1.CompletionItemKind.Variable;
        case PConst.Kind.memberVariable:
        case PConst.Kind.memberGetAccessor:
        case PConst.Kind.memberSetAccessor:
            return vscode_languageserver_protocol_1.CompletionItemKind.Field;
        case PConst.Kind.function:
            return vscode_languageserver_protocol_1.CompletionItemKind.Function;
        case PConst.Kind.memberFunction:
        case PConst.Kind.constructSignature:
        case PConst.Kind.callSignature:
        case PConst.Kind.indexSignature:
            return vscode_languageserver_protocol_1.CompletionItemKind.Method;
        case PConst.Kind.enum:
            return vscode_languageserver_protocol_1.CompletionItemKind.Enum;
        case PConst.Kind.module:
        case PConst.Kind.externalModuleName:
            return vscode_languageserver_protocol_1.CompletionItemKind.Module;
        case PConst.Kind.class:
        case PConst.Kind.type:
            return vscode_languageserver_protocol_1.CompletionItemKind.Class;
        case PConst.Kind.interface:
            return vscode_languageserver_protocol_1.CompletionItemKind.Interface;
        case PConst.Kind.warning:
        case PConst.Kind.script:
            return vscode_languageserver_protocol_1.CompletionItemKind.File;
        case PConst.Kind.directory:
            return vscode_languageserver_protocol_1.CompletionItemKind.Folder;
    }
    return vscode_languageserver_protocol_1.CompletionItemKind.Variable;
}
function getCommitCharacters(tsEntry, settings) {
    if (settings.isNewIdentifierLocation || !settings.isInValidCommitCharacterContext) {
        return undefined;
    }
    const commitCharacters = [];
    switch (tsEntry.kind) {
        case PConst.Kind.memberGetAccessor:
        case PConst.Kind.memberSetAccessor:
        case PConst.Kind.constructSignature:
        case PConst.Kind.callSignature:
        case PConst.Kind.indexSignature:
        case PConst.Kind.enum:
        case PConst.Kind.interface:
            commitCharacters.push('.', ';');
            break;
        case PConst.Kind.module:
        case PConst.Kind.alias:
        case PConst.Kind.const:
        case PConst.Kind.let:
        case PConst.Kind.variable:
        case PConst.Kind.localVariable:
        case PConst.Kind.memberVariable:
        case PConst.Kind.class:
        case PConst.Kind.function:
        case PConst.Kind.memberFunction:
        case PConst.Kind.keyword:
            commitCharacters.push('.', ',', ';');
            if (settings.useCodeSnippetsOnMethodSuggest) {
                commitCharacters.push('(');
            }
            break;
    }
    return commitCharacters.length === 0 ? undefined : commitCharacters;
}
function getParameterListParts(displayParts) {
    const parts = [];
    let isInMethod = false;
    let hasOptionalParameters = false;
    let parenCount = 0;
    let braceCount = 0;
    outer: for (let i = 0; i < displayParts.length; ++i) {
        const part = displayParts[i];
        switch (part.kind) {
            case PConst.DisplayPartKind.methodName:
            case PConst.DisplayPartKind.functionName:
            case PConst.DisplayPartKind.text:
            case PConst.DisplayPartKind.propertyName:
                if (parenCount === 0 && braceCount === 0) {
                    isInMethod = true;
                }
                break;
            case PConst.DisplayPartKind.parameterName:
                if (parenCount === 1 && isInMethod) {
                    // Only take top level paren names
                    const next = displayParts[i + 1];
                    // Skip optional parameters
                    const nameIsFollowedByOptionalIndicator = next && next.text === '?';
                    if (!nameIsFollowedByOptionalIndicator) {
                        parts.push(part);
                    }
                    hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;
                }
                break;
            case PConst.DisplayPartKind.punctuation:
                if (part.text === '(') {
                    ++parenCount;
                }
                else if (part.text === ')') {
                    --parenCount;
                    if (parenCount <= 0 && isInMethod) {
                        break outer;
                    }
                }
                else if (part.text === '...' && parenCount === 1) {
                    // Found rest parmeter. Do not fill in any further arguments
                    hasOptionalParameters = true;
                    break outer;
                }
                else if (part.text === '{') {
                    ++braceCount;
                }
                else if (part.text === '}') {
                    --braceCount;
                }
                break;
        }
    }
    return { hasOptionalParameters, parts };
}
exports.getParameterListParts = getParameterListParts;
//# sourceMappingURL=completionItem.js.map