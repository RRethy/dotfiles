"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const languageProvider_1 = tslib_1.__importDefault(require("./languageProvider"));
const PConst = tslib_1.__importStar(require("./protocol.const"));
const typescriptServiceClient_1 = tslib_1.__importDefault(require("./typescriptServiceClient"));
const typeConverters = tslib_1.__importStar(require("./utils/typeConverters"));
const typingsStatus_1 = tslib_1.__importStar(require("./utils/typingsStatus"));
// Style check diagnostics that can be reported as warnings
const styleCheckDiagnostics = [
    6133,
    6138,
    7027,
    7028,
    7029,
    7030 // not all code paths return a value
];
class TypeScriptServiceClientHost {
    constructor(descriptions) {
        this.languages = [];
        this.languagePerId = new Map();
        this.disposables = [];
        this.reportStyleCheckAsWarnings = true;
        const handleProjectChange = () => {
            setTimeout(() => {
                this.triggerAllDiagnostics();
            }, 1500);
        };
        const configFileWatcher = coc_nvim_1.workspace.createFileSystemWatcher('**/[tj]sconfig.json');
        this.disposables.push(configFileWatcher);
        configFileWatcher.onDidCreate(this.reloadProjects, this, this.disposables);
        configFileWatcher.onDidDelete(this.reloadProjects, this, this.disposables);
        configFileWatcher.onDidChange(handleProjectChange, this, this.disposables);
        this.client = new typescriptServiceClient_1.default();
        this.disposables.push(this.client);
        this.client.onDiagnosticsReceived(({ kind, resource, diagnostics }) => {
            this.diagnosticsReceived(kind, resource, diagnostics);
        }, null, this.disposables);
        this.client.onConfigDiagnosticsReceived(diag => {
            let { body } = diag;
            if (body) {
                let { configFile, diagnostics } = body;
                let uri = vscode_uri_1.default.file(configFile);
                let language = this.findLanguage(uri);
                if (!language)
                    return;
                if (diagnostics.length == 0) {
                    language.configFileDiagnosticsReceived(uri, []);
                }
                else {
                    let range = vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(0, 0), vscode_languageserver_protocol_1.Position.create(0, 1));
                    let { text, code, category } = diagnostics[0];
                    let severity = category == 'error' ? vscode_languageserver_protocol_1.DiagnosticSeverity.Error : vscode_languageserver_protocol_1.DiagnosticSeverity.Warning;
                    let diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(range, text, severity, code);
                    language.configFileDiagnosticsReceived(uri, [diagnostic]);
                }
            }
        }, null, this.disposables);
        this.typingsStatus = new typingsStatus_1.default(this.client);
        this.ataProgressReporter = new typingsStatus_1.AtaProgressReporter(this.client);
        for (const description of descriptions) { // tslint:disable-line
            const manager = new languageProvider_1.default(this.client, description, this.typingsStatus);
            this.languages.push(manager);
            this.disposables.push(manager);
            this.languagePerId.set(description.id, manager);
        }
        this.client.ensureServiceStarted();
        this.client.onTsServerStarted(() => {
            this.triggerAllDiagnostics();
        });
        this.configurationChanged();
    }
    dispose() {
        coc_nvim_1.disposeAll(this.disposables);
        this.typingsStatus.dispose();
        this.ataProgressReporter.dispose();
    }
    reset() {
        for (let lang of this.languages) {
            lang.fileConfigurationManager.reset();
        }
    }
    get serviceClient() {
        return this.client;
    }
    reloadProjects() {
        this.client.execute('reloadProjects', null, false); // tslint:disable-line
        this.triggerAllDiagnostics();
    }
    // typescript or javascript
    getProvider(languageId) {
        return this.languagePerId.get(languageId);
    }
    configurationChanged() {
        const config = coc_nvim_1.workspace.getConfiguration('tsserver');
        this.reportStyleCheckAsWarnings = config.get('reportStyleChecksAsWarnings', true);
    }
    findLanguage(resource) {
        try {
            return this.languages.find(language => language.handles(resource));
        }
        catch (_a) {
            return null;
        }
    }
    handles(uri) {
        return this.findLanguage(vscode_uri_1.default.parse(uri)) != null;
    }
    triggerAllDiagnostics() {
        for (const language of this.languagePerId.values()) {
            language.triggerAllDiagnostics();
        }
    }
    diagnosticsReceived(kind, resource, diagnostics) {
        const language = this.findLanguage(resource);
        if (language) {
            language.diagnosticsReceived(kind, resource, this.createMarkerDatas(diagnostics));
        }
    }
    createMarkerDatas(diagnostics) {
        return diagnostics.map(tsDiag => this.tsDiagnosticToLspDiagnostic(tsDiag));
    }
    tsDiagnosticToLspDiagnostic(diagnostic) {
        const { start, end, text } = diagnostic;
        const range = {
            start: typeConverters.Position.fromLocation(start),
            end: typeConverters.Position.fromLocation(end)
        };
        return {
            range,
            message: text,
            code: diagnostic.code ? diagnostic.code : null,
            severity: this.getDiagnosticSeverity(diagnostic),
            source: diagnostic.source || 'tsserver',
        };
    }
    getDiagnosticSeverity(diagnostic) {
        if (this.reportStyleCheckAsWarnings &&
            this.isStyleCheckDiagnostic(diagnostic.code) &&
            diagnostic.category === PConst.DiagnosticCategory.error) {
            return vscode_languageserver_protocol_1.DiagnosticSeverity.Warning;
        }
        switch (diagnostic.category) {
            case PConst.DiagnosticCategory.error:
                return vscode_languageserver_protocol_1.DiagnosticSeverity.Error;
            case PConst.DiagnosticCategory.warning:
                return vscode_languageserver_protocol_1.DiagnosticSeverity.Warning;
            case PConst.DiagnosticCategory.suggestion:
                return vscode_languageserver_protocol_1.DiagnosticSeverity.Information;
            default:
                return vscode_languageserver_protocol_1.DiagnosticSeverity.Error;
        }
    }
    isStyleCheckDiagnostic(code) {
        return code ? styleCheckDiagnostics.indexOf(code) !== -1 : false;
    }
}
exports.default = TypeScriptServiceClientHost;
//# sourceMappingURL=typescriptServiceClientHost.js.map