"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const coc_nvim_1 = require("coc.nvim");
const languageDescription_1 = require("./utils/languageDescription");
const languageModeIds_1 = require("./utils/languageModeIds");
const typeconverts = tslib_1.__importStar(require("./utils/typeConverters"));
class OrganizeImportsCommand {
    constructor(client) {
        this.client = client;
        this.id = 'tsserver.organizeImports';
        coc_nvim_1.workspace.onWillSaveUntil(this.onWillSaveUntil, this, 'tsserver');
    }
    onWillSaveUntil(event) {
        let config = coc_nvim_1.workspace.getConfiguration('tsserver');
        let format = config.get('orgnizeImportOnSave', false);
        if (!format)
            return;
        let { document } = event;
        if (languageModeIds_1.languageIds.indexOf(document.languageId) == -1)
            return;
        let willSaveWaitUntil = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let edit = yield this.getTextEdits(document);
            if (!edit)
                return [];
            return edit.changes ? edit.changes[document.uri] : [];
        });
        event.waitUntil(willSaveWaitUntil());
    }
    getTextEdits(document) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let client = this.client.serviceClient;
            let file = client.toPath(document.uri);
            const args = {
                scope: {
                    type: 'file',
                    args: {
                        file
                    }
                }
            };
            const response = yield client.execute('organizeImports', args);
            if (!response || !response.success) {
                return;
            }
            const edit = typeconverts.WorkspaceEdit.fromFileCodeEdits(client, response.body);
            let desc = languageDescription_1.standardLanguageDescriptions.find(o => o.modeIds.indexOf(document.languageId) !== -1);
            if (!desc)
                return null;
            const config = coc_nvim_1.workspace.getConfiguration(`${desc.id}.preferences`);
            let noSemicolons = config.get('noSemicolons', false);
            if (noSemicolons) {
                let { changes } = edit;
                if (changes) {
                    for (let c of Object.keys(changes)) {
                        for (let textEdit of changes[c]) {
                            textEdit.newText = textEdit.newText.replace(/;/g, '');
                        }
                    }
                }
            }
            return edit;
        });
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let document = yield coc_nvim_1.workspace.document;
            if (languageModeIds_1.languageIds.indexOf(document.filetype) == -1)
                return;
            let edit = yield this.getTextEdits(document.textDocument);
            if (edit)
                yield coc_nvim_1.workspace.applyEdit(edit);
            return;
        });
    }
}
exports.default = OrganizeImportsCommand;
//# sourceMappingURL=organizeImports.js.map