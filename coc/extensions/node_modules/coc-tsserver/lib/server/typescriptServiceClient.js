"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const find_up_1 = tslib_1.__importDefault(require("find-up"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const which_1 = tslib_1.__importDefault(require("which"));
const coc_nvim_1 = require("coc.nvim");
const fileConfigurationManager_1 = tslib_1.__importDefault(require("./features/fileConfigurationManager"));
const api_1 = tslib_1.__importDefault(require("./utils/api"));
const configuration_1 = require("./utils/configuration");
const logger_1 = tslib_1.__importDefault(require("./utils/logger"));
const process_1 = require("./utils/process");
const languageModeIds_1 = require("./utils/languageModeIds");
const tracer_1 = tslib_1.__importDefault(require("./utils/tracer"));
const tsconfig_1 = require("./utils/tsconfig");
const versionProvider_1 = require("./utils/versionProvider");
const versionStatus_1 = tslib_1.__importDefault(require("./utils/versionStatus"));
const wireProtocol_1 = require("./utils/wireProtocol");
class CallbackMap {
    constructor() {
        this.callbacks = new Map();
        this.pendingResponses = 0;
    }
    destroy(e) {
        for (const callback of this.callbacks.values()) {
            callback.e(e);
        }
        this.callbacks.clear();
        this.pendingResponses = 0;
    }
    add(seq, callback) {
        this.callbacks.set(seq, callback);
        ++this.pendingResponses;
    }
    fetch(seq) {
        const callback = this.callbacks.get(seq);
        this.delete(seq);
        return callback;
    }
    delete(seq) {
        if (this.callbacks.delete(seq)) {
            --this.pendingResponses;
        }
    }
}
class RequestQueue {
    constructor() {
        this.queue = [];
        this.sequenceNumber = 0;
    }
    get length() {
        return this.queue.length;
    }
    push(item) {
        this.queue.push(item);
    }
    shift() {
        return this.queue.shift();
    }
    tryCancelPendingRequest(seq) {
        for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i].request.seq === seq) {
                this.queue.splice(i, 1);
                return true;
            }
        }
        return false;
    }
    createRequest(command, args) {
        return {
            seq: this.sequenceNumber++,
            type: 'request',
            command,
            arguments: args
        };
    }
}
class ForkedTsServerProcess {
    constructor(childProcess) {
        this.childProcess = childProcess;
    }
    onError(cb) {
        this.childProcess.on('error', cb);
    }
    onExit(cb) {
        this.childProcess.on('exit', cb);
    }
    write(serverRequest) {
        this.childProcess.stdin.write(JSON.stringify(serverRequest) + '\r\n', 'utf8');
    }
    createReader(callback, onError) {
        // tslint:disable-next-line:no-unused-expression
        new wireProtocol_1.Reader(this.childProcess.stdout, callback, onError);
    }
    kill() {
        this.childProcess.kill();
    }
}
class TypeScriptServiceClient {
    constructor() {
        this.state = coc_nvim_1.ServiceStat.Initial;
        this.logger = new logger_1.default();
        this.tsServerLogFile = null;
        this.cancellationPipeName = null;
        this._onTsServerStarted = new vscode_languageserver_protocol_1.Emitter();
        this._onProjectLanguageServiceStateChanged = new vscode_languageserver_protocol_1.Emitter();
        this._onDidBeginInstallTypings = new vscode_languageserver_protocol_1.Emitter();
        this._onDidEndInstallTypings = new vscode_languageserver_protocol_1.Emitter();
        this._onTypesInstallerInitializationFailed = new vscode_languageserver_protocol_1.Emitter();
        this.disposables = [];
        this._onDiagnosticsReceived = new vscode_languageserver_protocol_1.Emitter();
        this._onConfigDiagnosticsReceived = new vscode_languageserver_protocol_1.Emitter();
        this._onResendModelsRequested = new vscode_languageserver_protocol_1.Emitter();
        this.pathSeparator = path_1.default.sep;
        this.lastStart = Date.now();
        this.servicePromise = null;
        this.lastError = null;
        this.numberRestarts = 0;
        this.fileConfigurationManager = new fileConfigurationManager_1.default(this);
        this.requestQueue = new RequestQueue();
        this.callbacks = new CallbackMap();
        this._configuration = configuration_1.TypeScriptServiceConfiguration.loadFromWorkspace();
        this.versionProvider = new versionProvider_1.TypeScriptVersionProvider(this._configuration);
        this._apiVersion = api_1.default.defaultVersion;
        this.tracer = new tracer_1.default(this.logger);
        this.versionStatus = new versionStatus_1.default(this.normalizePath.bind(this));
    }
    get onDiagnosticsReceived() {
        return this._onDiagnosticsReceived.event;
    }
    get onConfigDiagnosticsReceived() {
        return this._onConfigDiagnosticsReceived.event;
    }
    get onResendModelsRequested() {
        return this._onResendModelsRequested.event;
    }
    get configuration() {
        return this._configuration;
    }
    dispose() {
        if (this.servicePromise) {
            this.servicePromise
                .then(childProcess => {
                childProcess.kill();
            })
                .then(undefined, () => void 0);
        }
        coc_nvim_1.disposeAll(this.disposables);
        this.logger.dispose();
        this._onTsServerStarted.dispose();
        this._onResendModelsRequested.dispose();
    }
    info(message, data) {
        this.logger.info(message, data);
    }
    error(message, data) {
        this.logger.error(message, data);
    }
    restartTsServer() {
        const start = () => {
            this.servicePromise = this.startService(true);
            return this.servicePromise;
        };
        if (this.servicePromise) {
            return Promise.resolve(this.servicePromise.then(childProcess => {
                this.state = coc_nvim_1.ServiceStat.Stopping;
                this.info('Killing TS Server');
                childProcess.kill();
                this.servicePromise = null;
            }).then(start));
        }
        else {
            return Promise.resolve(start());
        }
    }
    stop() {
        if (!this.servicePromise)
            return;
        return new Promise((resolve, reject) => {
            this.servicePromise.then(childProcess => {
                if (this.state == coc_nvim_1.ServiceStat.Running) {
                    this.info('Killing TS Server');
                    childProcess.onExit(() => {
                        resolve();
                    });
                    childProcess.kill();
                    this.servicePromise = null;
                }
                else {
                    resolve();
                }
            }, reject);
        });
    }
    get onTsServerStarted() {
        return this._onTsServerStarted.event;
    }
    get onProjectLanguageServiceStateChanged() {
        return this._onProjectLanguageServiceStateChanged.event;
    }
    get onDidBeginInstallTypings() {
        return this._onDidBeginInstallTypings.event;
    }
    get onDidEndInstallTypings() {
        return this._onDidEndInstallTypings.event;
    }
    get onTypesInstallerInitializationFailed() {
        return this._onTypesInstallerInitializationFailed.event;
    }
    get apiVersion() {
        return this._apiVersion;
    }
    service() {
        if (this.servicePromise) {
            return this.servicePromise;
        }
        if (this.lastError) {
            return Promise.reject(this.lastError);
        }
        return this.startService().then(() => {
            if (this.servicePromise) {
                return this.servicePromise;
            }
        });
    }
    ensureServiceStarted() {
        if (!this.servicePromise) {
            this.startService().catch(err => {
                coc_nvim_1.workspace.showMessage(`TSServer start failed: ${err.message}`, 'error');
                this.error(`Service start failed: ${err.stack}`);
            });
        }
    }
    startService(resendModels = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let currentVersion = this.versionProvider.getLocalVersion(coc_nvim_1.workspace.root);
            if (!currentVersion || !fs_1.default.existsSync(currentVersion.tsServerPath)) {
                currentVersion = yield this.versionProvider.getDefaultVersion();
            }
            if (!currentVersion || !currentVersion.isValid) {
                coc_nvim_1.workspace.showMessage(`Can not find tsserver, run ':CocInstall coc-tsserver' to fix it!`, 'error');
                return;
            }
            coc_nvim_1.workspace.showMessage(`Using tsserver from: ${currentVersion.path}`); // tslint:disable-line
            this._apiVersion = currentVersion.version;
            this.versionStatus.onDidChangeTypeScriptVersion(currentVersion);
            this.requestQueue = new RequestQueue();
            this.callbacks = new CallbackMap();
            this.lastError = null;
            const tsServerForkArgs = yield this.getTsServerArgs();
            const debugPort = this._configuration.debugPort;
            const options = {
                execArgv: debugPort ? [`--inspect=${debugPort}`] : [],
                cwd: coc_nvim_1.workspace.root
            };
            this.servicePromise = this.startProcess(currentVersion, tsServerForkArgs, options, resendModels);
            return this.servicePromise;
        });
    }
    startProcess(currentVersion, args, options, resendModels) {
        this.state = coc_nvim_1.ServiceStat.Starting;
        return new Promise((resolve, reject) => {
            try {
                process_1.fork(currentVersion.tsServerPath, args, options, this.logger, (err, childProcess) => {
                    if (err || !childProcess) {
                        this.state = coc_nvim_1.ServiceStat.StartFailed;
                        this.lastError = err;
                        this.error('Starting TSServer failed with error.', err.stack);
                        return;
                    }
                    this.state = coc_nvim_1.ServiceStat.Running;
                    this.info('Started TSServer', JSON.stringify(currentVersion, null, 2));
                    const handle = new ForkedTsServerProcess(childProcess);
                    this.lastStart = Date.now();
                    handle.onError((err) => {
                        this.lastError = err;
                        this.error('TSServer errored with error.', err);
                        this.error(`TSServer log file: ${this.tsServerLogFile || ''}`);
                        coc_nvim_1.workspace.showMessage(`TSServer errored with error. ${err.message}`, 'error');
                        this.serviceExited(false);
                    });
                    handle.onExit((code) => {
                        if (code == null) {
                            this.info('TSServer normal exit');
                        }
                        else {
                            this.error(`TSServer exited with code: ${code}`);
                        }
                        this.info(`TSServer log file: ${this.tsServerLogFile || ''}`);
                        this.serviceExited(code != null);
                    });
                    handle.createReader(msg => {
                        this.dispatchMessage(msg);
                    }, error => {
                        this.error('ReaderError', error);
                    });
                    resolve(handle);
                    this.serviceStarted(resendModels);
                    this._onTsServerStarted.fire(currentVersion.version);
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    openTsServerLogFile() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const isRoot = process.getuid && process.getuid() == 0;
            let echoErr = (msg) => {
                coc_nvim_1.workspace.showMessage(msg, 'error');
            };
            if (isRoot) {
                echoErr('Log disabled for root user.');
                return false;
            }
            if (!this.apiVersion.gte(api_1.default.v222)) {
                echoErr('TS Server logging requires TS 2.2.2+');
                return false;
            }
            if (this._configuration.tsServerLogLevel === configuration_1.TsServerLogLevel.Off) {
                echoErr(`TS Server logging is off. Change 'tsserver.log' in 'coc-settings.json' to enable`);
                return false;
            }
            if (!this.tsServerLogFile) {
                echoErr('TS Server has not started logging.');
                return false;
            }
            try {
                yield coc_nvim_1.workspace.nvim.command(`edit ${this.tsServerLogFile}`);
                return true;
            }
            catch (_a) {
                echoErr('Could not open TS Server log file');
                return false;
            }
        });
    }
    serviceStarted(resendModels) {
        let document = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.bufnr);
        if (document && languageModeIds_1.languageIds.indexOf(document.filetype) !== -1) {
            this.fileConfigurationManager.ensureConfigurationForDocument(document.textDocument); // tslint:disable-line
        }
        else {
            const configureOptions = {
                hostInfo: 'nvim-coc'
            };
            this.execute('configure', configureOptions); // tslint:disable-line
        }
        this.setCompilerOptionsForInferredProjects(this._configuration);
        if (resendModels) {
            this._onResendModelsRequested.fire(void 0);
        }
    }
    setCompilerOptionsForInferredProjects(configuration) {
        if (!this.apiVersion.gte(api_1.default.v206))
            return;
        const args = {
            options: this.getCompilerOptionsForInferredProjects(configuration)
        };
        this.execute('compilerOptionsForInferredProjects', args, true); // tslint:disable-line
    }
    getCompilerOptionsForInferredProjects(configuration) {
        return Object.assign({}, tsconfig_1.inferredProjectConfig(configuration), { allowJs: true, allowSyntheticDefaultImports: true, allowNonTsExtensions: true });
    }
    serviceExited(restart) {
        this.state = coc_nvim_1.ServiceStat.Stopped;
        this.servicePromise = null;
        this.tsServerLogFile = null;
        this.callbacks.destroy(new Error('Service died.'));
        this.callbacks = new CallbackMap();
        if (restart) {
            const diff = Date.now() - this.lastStart;
            this.numberRestarts++;
            let startService = true;
            if (this.numberRestarts > 5) {
                this.numberRestarts = 0;
                if (diff < 10 * 1000 /* 10 seconds */) {
                    this.lastStart = Date.now();
                    startService = false;
                    coc_nvim_1.workspace.showMessage('The TypeScript language service died 5 times right after it got started.', 'error'); // tslint:disable-line
                }
                else if (diff < 60 * 1000 /* 1 Minutes */) {
                    this.lastStart = Date.now();
                    coc_nvim_1.workspace.showMessage('The TypeScript language service died unexpectedly 5 times in the last 5 Minutes.', 'error'); // tslint:disable-line
                }
            }
            if (startService) {
                this.startService(true); // tslint:disable-line
            }
        }
    }
    toPath(uri) {
        return this.normalizePath(vscode_uri_1.default.parse(uri));
    }
    toResource(filepath) {
        if (this._apiVersion.gte(api_1.default.v213)) {
            if (filepath.startsWith('untitled:')) {
                let resource = vscode_uri_1.default.parse(filepath);
                if (this.inMemoryResourcePrefix) {
                    const dirName = path_1.default.dirname(resource.path);
                    const fileName = path_1.default.basename(resource.path);
                    if (fileName.startsWith(this.inMemoryResourcePrefix)) {
                        resource = resource.with({ path: path_1.default.posix.join(dirName, fileName.slice(this.inMemoryResourcePrefix.length)) });
                    }
                }
                return resource.toString();
            }
        }
        return vscode_uri_1.default.file(filepath).toString();
    }
    normalizePath(resource) {
        if (this._apiVersion.gte(api_1.default.v213)) {
            if (resource.scheme !== 'file') {
                const dirName = path_1.default.dirname(resource.path);
                const fileName = this.inMemoryResourcePrefix + path_1.default.basename(resource.path);
                return resource
                    .with({ path: path_1.default.posix.join(dirName, fileName) })
                    .toString(true);
            }
        }
        const result = resource.fsPath;
        if (!result)
            return null;
        // Both \ and / must be escaped in regular expressions
        return result.replace(new RegExp('\\' + this.pathSeparator, 'g'), '/');
    }
    get inMemoryResourcePrefix() {
        return this._apiVersion.gte(api_1.default.v270) ? '^' : '';
    }
    asUrl(filepath) {
        if (this._apiVersion.gte(api_1.default.v213)) {
            if (filepath.startsWith('untitled:')) {
                let resource = vscode_uri_1.default.parse(filepath);
                if (this.inMemoryResourcePrefix) {
                    const dirName = path_1.default.dirname(resource.path);
                    const fileName = path_1.default.basename(resource.path);
                    if (fileName.startsWith(this.inMemoryResourcePrefix)) {
                        resource = resource.with({
                            path: path_1.default.posix.join(dirName, fileName.slice(this.inMemoryResourcePrefix.length))
                        });
                    }
                }
                return resource;
            }
        }
        return vscode_uri_1.default.file(filepath);
    }
    execute(command, args, expectsResultOrToken) {
        if (this.servicePromise == null) {
            return Promise.resolve();
        }
        let token;
        let expectsResult = true;
        if (typeof expectsResultOrToken === 'boolean') {
            expectsResult = expectsResultOrToken;
        }
        else {
            token = expectsResultOrToken;
        }
        const request = this.requestQueue.createRequest(command, args);
        const requestInfo = {
            request,
            callbacks: null
        };
        let result;
        if (expectsResult) {
            let wasCancelled = false;
            result = new Promise((resolve, reject) => {
                requestInfo.callbacks = { c: resolve, e: reject, start: Date.now() };
                if (token) {
                    token.onCancellationRequested(() => {
                        wasCancelled = true;
                        this.tryCancelRequest(request.seq);
                    });
                }
            }).catch((err) => {
                if (!wasCancelled && command != 'signatureHelp') {
                    this.error(`'${command}' request failed with error.`, err);
                }
                throw err;
            });
        }
        else {
            result = Promise.resolve(null);
        }
        this.requestQueue.push(requestInfo);
        this.sendNextRequests();
        return result;
    }
    sendNextRequests() {
        while (this.callbacks.pendingResponses === 0 &&
            this.requestQueue.length > 0) {
            const item = this.requestQueue.shift();
            if (item) {
                this.sendRequest(item);
            }
        }
    }
    sendRequest(requestItem) {
        const serverRequest = requestItem.request;
        this.tracer.traceRequest(serverRequest, !!requestItem.callbacks, this.requestQueue.length);
        if (requestItem.callbacks) {
            this.callbacks.add(serverRequest.seq, requestItem.callbacks);
        }
        this.service()
            .then(childProcess => {
            childProcess.write(serverRequest);
        })
            .then(undefined, err => {
            const callback = this.callbacks.fetch(serverRequest.seq);
            if (callback) {
                callback.e(err);
            }
        });
    }
    tryCancelRequest(seq) {
        try {
            if (this.requestQueue.tryCancelPendingRequest(seq)) {
                this.tracer.logTrace(`TypeScript Service: canceled request with sequence number ${seq}`);
                return true;
            }
            if (this.apiVersion.gte(api_1.default.v222) && this.cancellationPipeName) {
                this.tracer.logTrace(`TypeScript Service: trying to cancel ongoing request with sequence number ${seq}`);
                try {
                    fs_1.default.writeFileSync(this.cancellationPipeName + seq, '');
                }
                catch (_a) {
                    // noop
                }
                return true;
            }
            this.tracer.logTrace(`TypeScript Service: tried to cancel request with sequence number ${seq}. But request got already delivered.`);
            return false;
        }
        finally {
            const p = this.callbacks.fetch(seq);
            if (p) {
                p.e(new Error(`Cancelled Request ${seq}`));
            }
        }
    }
    dispatchMessage(message) {
        try {
            if (message.type === 'response') {
                const response = message;
                const p = this.callbacks.fetch(response.request_seq);
                if (p) {
                    this.tracer.traceResponse(response, p.start);
                    if (response.success) {
                        p.c(response);
                    }
                    else {
                        p.e(response);
                    }
                }
            }
            else if (message.type === 'event') {
                const event = message;
                this.tracer.traceEvent(event);
                this.dispatchEvent(event);
            }
            else {
                throw new Error('Unknown message type ' + message.type + ' received');
            }
        }
        finally {
            this.sendNextRequests();
        }
    }
    dispatchEvent(event) {
        switch (event.event) {
            case 'syntaxDiag':
            case 'semanticDiag':
            case 'suggestionDiag':
                const diagnosticEvent = event;
                if (diagnosticEvent.body && diagnosticEvent.body.diagnostics) {
                    this._onDiagnosticsReceived.fire({
                        kind: getDignosticsKind(event),
                        resource: this.asUrl(diagnosticEvent.body.file),
                        diagnostics: diagnosticEvent.body.diagnostics
                    });
                }
                break;
            case 'configFileDiag':
                this._onConfigDiagnosticsReceived.fire(event);
                break;
            case 'projectLanguageServiceState':
                if (event.body) {
                    this._onProjectLanguageServiceStateChanged.fire(event.body);
                }
                break;
            case 'beginInstallTypes':
                if (event.body) {
                    this._onDidBeginInstallTypings.fire(event.body);
                }
                break;
            case 'endInstallTypes':
                if (event.body) {
                    this._onDidEndInstallTypings.fire(event.body);
                }
                break;
            case 'typesInstallerInitializationFailed':
                if (event.body) {
                    this._onTypesInstallerInitializationFailed.fire(event.body);
                }
                break;
        }
    }
    getTsServerArgs() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const args = [];
            args.push('--allowLocalPluginLoads');
            if (this.apiVersion.gte(api_1.default.v250)) {
                args.push('--useInferredProjectPerProjectRoot');
            }
            else {
                args.push('--useSingleInferredProject');
            }
            if (this.apiVersion.gte(api_1.default.v206) && this._configuration.disableAutomaticTypeAcquisition) {
                args.push('--disableAutomaticTypingAcquisition');
            }
            if (this.apiVersion.gte(api_1.default.v222)) {
                this.cancellationPipeName = process_1.getTempFile(`tscancellation-${process_1.makeRandomHexString(20)}`);
                args.push('--cancellationPipeName', this.cancellationPipeName + '*');
            }
            if (this.apiVersion.gte(api_1.default.v222)) {
                const isRoot = process.getuid && process.getuid() == 0;
                if (this._configuration.tsServerLogLevel !== configuration_1.TsServerLogLevel.Off && !isRoot) {
                    const logDir = os_1.default.tmpdir();
                    if (logDir) {
                        this.tsServerLogFile = path_1.default.join(logDir, `coc-nvim-tsc.log`);
                        this.info('TSServer log file :', this.tsServerLogFile);
                    }
                    else {
                        this.tsServerLogFile = null;
                        this.error('Could not create TSServer log directory');
                    }
                    if (this.tsServerLogFile) {
                        args.push('--logVerbosity', configuration_1.TsServerLogLevel.toString(this._configuration.tsServerLogLevel));
                        args.push('--logFile', this.tsServerLogFile);
                    }
                }
            }
            if (this.apiVersion.gte(api_1.default.v230)) {
                const plugins = this._configuration.tsServerPluginNames;
                const pluginRoot = this._configuration.tsServerPluginRoot;
                if (plugins.length) {
                    args.push('--globalPlugins', plugins.join(','));
                    if (pluginRoot) {
                        args.push('--pluginProbeLocations', pluginRoot);
                    }
                }
            }
            if (this._configuration.typingsCacheLocation) {
                args.push('--globalTypingsCacheLocation', `"${this._configuration.typingsCacheLocation}"`);
            }
            if (this.apiVersion.gte(api_1.default.v234)) {
                if (this._configuration.npmLocation) {
                    args.push('--npmLocation', `"${this._configuration.npmLocation}"`);
                }
                else {
                    try {
                        args.push('--npmLocation', `"${which_1.default.sync('npm')}"`);
                    }
                    catch (e) { } // tslint:disable-line
                }
            }
            if (this.apiVersion.gte(api_1.default.v291)) {
                args.push('--noGetErrOnBackgroundUpdate');
            }
            return args;
        });
    }
    getWorkspaceRootForResource(uri) {
        let u = vscode_uri_1.default.parse(uri);
        if (u.scheme != 'file')
            return coc_nvim_1.workspace.root;
        let res = find_up_1.default.sync(['package.json', '.vim', '.git', '.hg'], { cwd: path_1.default.dirname(u.fsPath) });
        return res ? path_1.default.dirname(res) : null;
    }
}
exports.default = TypeScriptServiceClient;
function getDignosticsKind(event) {
    switch (event.event) {
        case 'syntaxDiag':
            return coc_nvim_1.DiagnosticKind.Syntax;
        case 'semanticDiag':
            return coc_nvim_1.DiagnosticKind.Semantic;
        case 'suggestionDiag':
            return coc_nvim_1.DiagnosticKind.Suggestion;
    }
    throw new Error('Unknown dignostics kind');
}
//# sourceMappingURL=typescriptServiceClient.js.map